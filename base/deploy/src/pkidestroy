#!/usr/bin/python -t
# Authors:
#     Matthew Harmsen <mharmsen@redhat.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Copyright (C) 2011 Red Hat, Inc.
# All rights reserved.
#

# System Imports
import sys
if not hasattr(sys, "hexversion") or sys.hexversion < 0x020700f0:
    print "Python version %s.%s.%s is too old." % sys.version_info[:3]
    print "Please upgrade to at least Python 2.7.0."
    sys.exit(1)
try:
    import argparse
    import logging
    import os
    import pprint
    import random
    import socket
    import string
    import struct
    import subprocess
    import time
    from time import strftime as date
    from pki.deployment import pkiconfig as config
    from pki.deployment import pkiparser as parse
    from pki.deployment import pkilogging
    from pki.deployment import pkimessages as log
except ImportError:
    print >> sys.stderr, """\
There was a problem importing one of the required Python modules. The
error was:

    %s
""" % sys.exc_value
    sys.exit(1)


# PKI Deployment Functions
def main(argv):
    "main entry point"

    # Only run this program as "root".
    if not os.geteuid() == 0:
        sys.exit("'%s' must be run as root!" % argv[0])

    # Set the umask
    os.umask(config.PKI_DEPLOYMENT_DEFAULT_UMASK)

    # Set installation time
    ticks = time.time()
    config.pki_install_time = time.asctime(time.localtime(ticks))

    # Generate a timestamp
    config.pki_timestamp = date('%Y%m%d%H%M%S', time.localtime(ticks))
    config.pki_certificate_timestamp =\
        date('%Y-%m-%d %H:%M:%S', time.localtime(ticks))

    # Obtain the architecture bit-size
    config.pki_architecture = struct.calcsize("P") * 8

    # Retrieve hostname
    config.pki_hostname = socket.getfqdn()

    # Retrieve DNS domainname
    config.pki_dns_domainname = None
    try:
        config.pki_dns_domainname = subprocess.check_output("domainname",
                                                            shell=True)
        config.pki_dns_domainname = config.pki_dns_domainname.rstrip('\n')
        if not len(config.pki_dns_domainname):
            print log.PKI_DNS_DOMAIN_NOT_SET
            sys.exit(1)
    except subprocess.CalledProcessError as exc:
        print log.PKI_SUBPROCESS_ERROR_1 % exc
        sys.exit(1)

    # Initialize 'pretty print' for objects
    pp = pprint.PrettyPrinter(indent=4)

    # Read and process command-line arguments.
    parse.process_command_line_arguments(argv)

    # Enable 'pkidestroy' logging.
    if not config.pki_dry_run_flag:
        config.pki_log_dir = config.pki_root_prefix +\
                             config.PKI_DEPLOYMENT_LOG_ROOT
        config.pki_log_name = "pki" + "-" +\
                              config.pki_subsystem.lower() +\
                              "-" + "destroy" + "." +\
                              config.pki_timestamp + "." + "log"
    else:
        config.pki_log_dir = "/dev"
        config.pki_log_name = "null"
    rv = pkilogging.enable_pki_logger(config.pki_log_dir,
                                      config.pki_log_name,
                                      config.pki_log_level,
                                      config.pki_console_log_level,
                                      "pkidestroy")
    if rv != OSError:
        config.pki_log = rv
    else:
        print log.PKI_UNABLE_TO_CREATE_LOG_DIRECTORY_1 % config.pki_log_dir
        sys.exit(1)

    # Read the specified PKI configuration file.
    rv = parse.read_pki_configuration_file()
    if rv != 0:
        config.pki_log.error(PKI_UNABLE_TO_PARSE_1, rv,
                             extra=config.PKI_INDENTATION_LEVEL_0)
        sys.exit(1)
    else:
        # NEVER print out 'sensitive' name/value pairs!!!
        config.pki_log.debug(log.PKI_DICTIONARY_COMMON,
                             extra=config.PKI_INDENTATION_LEVEL_0)
        config.pki_log.debug(pp.pformat(config.pki_common_dict),
                             extra=config.PKI_INDENTATION_LEVEL_0)
        config.pki_log.debug(log.PKI_DICTIONARY_WEB_SERVER,
                             extra=config.PKI_INDENTATION_LEVEL_0)
        config.pki_log.debug(pp.pformat(config.pki_web_server_dict),
                             extra=config.PKI_INDENTATION_LEVEL_0)
        config.pki_log.debug(log.PKI_DICTIONARY_SUBSYSTEM,
                             extra=config.PKI_INDENTATION_LEVEL_0)
        config.pki_log.debug(pp.pformat(config.pki_subsystem_dict),
                             extra=config.PKI_INDENTATION_LEVEL_0)

    # Override PKI configuration file values with 'custom' command-line values.
    if not config.custom_pki_admin_domain_name is None:
        config.pki_common_dict['pki_admin_domain_name'] =\
            config.custom_pki_admin_domain_name
    if not config.custom_pki_instance_name is None:
        config.pki_web_server_dict['pki_instance_name'] =\
            config.custom_pki_instance_name
    if not config.custom_pki_http_port is None:
        config.pki_web_server_dict['pki_http_port'] =\
            config.custom_pki_http_port
    if not config.custom_pki_https_port is None:
        config.pki_web_server_dict['pki_https_port'] =\
            config.custom_pki_https_port
    if not config.custom_pki_ajp_port is None:
        config.pki_web_server_dict['pki_ajp_port'] =\
            config.custom_pki_ajp_port
    # NEVER print out 'sensitive' name/value pairs!!!
    config.pki_log.debug(log.PKI_DICTIONARY_COMMON,
                         extra=config.PKI_INDENTATION_LEVEL_0)
    config.pki_log.debug(pp.pformat(config.pki_common_dict),
                         extra=config.PKI_INDENTATION_LEVEL_0)
    config.pki_log.debug(log.PKI_DICTIONARY_WEB_SERVER,
                         extra=config.PKI_INDENTATION_LEVEL_0)
    config.pki_log.debug(pp.pformat(config.pki_web_server_dict),
                         extra=config.PKI_INDENTATION_LEVEL_0)
    config.pki_log.debug(log.PKI_DICTIONARY_SUBSYSTEM,
                         extra=config.PKI_INDENTATION_LEVEL_0)
    config.pki_log.debug(pp.pformat(config.pki_subsystem_dict),
                         extra=config.PKI_INDENTATION_LEVEL_0)

    # Combine the various sectional dictionaries into a PKI master dictionary
    parse.compose_pki_master_dictionary()
    config.pki_master_dict['pki_destroy_log'] = config.pki_log_dir + "/" +\
                                                config.pki_log_name
    config.pki_log.debug(log.PKI_DICTIONARY_MASTER,
                         extra=config.PKI_INDENTATION_LEVEL_0)
    config.pki_log.debug(pp.pformat(config.pki_master_dict),
                         extra=config.PKI_INDENTATION_LEVEL_0)

    # Remove the specified PKI subsystem.
    pki_scriptlets_path = "/usr/share/pki/deployment/destroy" +\
                          "/" + config.pki_subsystem.lower()
    if not os.path.exists(pki_scriptlets_path) or\
       not os.path.isdir(pki_scriptlets_path):
        config.pki_log.error(log.PKI_DIRECTORY_MISSING_OR_NOT_A_DIRECTORY_1,
                             pki_scriptlets_path,
                             extra=config.PKI_INDENTATION_LEVEL_0)
        sys.exit(1)
    pki_subsystem_scriptlets = os.listdir(pki_scriptlets_path)
    pki_subsystem_scriptlets.sort()

    # Process the various "scriptlets" for the specified PKI subsystem.
    rv = 0
    for pki_scriptlet in pki_subsystem_scriptlets:
        scriptlet = __import__("pki.deployment" +\
                               "." + pki_scriptlet[4:],
                               fromlist = [pki_scriptlet[4:]])
        instance = scriptlet.PkiScriptlet()
        rv = instance.destroy()
        if rv != 0:
            sys.exit(1)
    config.pki_log.debug(log.PKI_DICTIONARY_MASTER,
                         extra=config.PKI_INDENTATION_LEVEL_0)
    config.pki_log.debug(pp.pformat(config.pki_master_dict),
                         extra=config.PKI_INDENTATION_LEVEL_0)


# PKI Deployment Entry Point
if __name__ == "__main__":
    main(sys.argv)
